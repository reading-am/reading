#-----------------------------------------
# App Structure

Reading =
  Models: {}
  Collections: {}
  Routers: {}
  Views: {}

<% if Rails.env == 'development' %>
window.r_ = Reading
<% end %>

#-----------------------------------------
# Libs

libs = {}

<%= IO.read "#{Rails.root}/app/assets/javascripts/libs/base58.coffee" %>
base58 = libs.encdec()

<% ['underscore','hogan','backbone'].each do |lib| %>
`<%= IO.read "#{Rails.root}/app/assets/javascripts/libs/#{lib}.js" %>`
<% end %>

#-----------------------------------------
# Debug

log = <% if Rails.env == 'development' %> -> console.log.apply console, arguments <% else %> -> <% end %>

#-----------------------------------------
# Config Vars

DOMAIN = "<%= DOMAIN %>"
SHORT_DOMAIN = "<%= SHORT_DOMAIN %>"
win_focus = true
reading.ready = false
on_reading = window.location.host.indexOf("reading.am") is 0 or
             window.location.host.indexOf("staging.reading.am") is 0 or
             window.location.host.indexOf("0.0.0.0") is 0
token = reading.token ? null
platform = reading.platform ? (if on_reading then "redirect" else "bookmarklet")
version = reading.version ? "0.0.0"

latest_versions =
  bookmarklet: "<%= BOOKMARKLET_VERSION %>"

#-----------------------------------------
# Content Vars

active = "r_active"
inactive = "r_inactive"
errors =
  general: "Sorry, something went wrong. If you keep getting this error, would you mind letting us know at hello@reading.am?"
  forbidden: "** You must be signed in to post to Reading **\nSign in or create an account at http://#{DOMAIN}"
  loading: "Sorry, we were unable to load Reading. If you keep getting this error, would you mind letting us know at hello@reading.am?"

#-----------------------------------------
# Helpers

parse_url = ->
  url = window.location.href.split(window.location.host)[1].substring(1)
  while url.substring(0, 2) is 't/' or url.substring(0, 2) is 'p/'
    url = url.substring(url.indexOf('/', 2) + 1)
  url = "http://#{url}" if url.indexOf('://') is -1
  url

popup = (url, width, height) ->
  window.open url, "r_win", "location=0,toolbars=0,status=0,directories=0,menubar=0,resizable=0,width=#{width},height=#{height}"

#-----------------------------------------
# Models

#######
# API #
#######
class API

API::call = (method, params) ->
    data = if params.data? then params.data else {}
    data.token = token if token

    complete = if params.complete? then params.complete else ->
    success = if params.success? then params.success else log
    error = if params.error? then params.error else (jqXHR, textStatus, errorThrown) ->
      log jqXHR, textStatus, errorThrown
      switch errorThrown
        when "Bad Request"
          alert errors.general
        when "Forbidden"
          alert errors.forbidden

    $.ajax
      url: "//#{DOMAIN}/#{method}.json"
      dataType: "jsonp"
      data: data
      complete: complete
      error: error
      success: (data, textStatus, jqXHR) ->
        if data.meta.status < 400
          success Model::factory(data.response)
        else
          jqXHR.status = data.meta.status
          jqXHR.responseText = data
          error jqXHR, textStatus, data.meta.msg

#########
# Model #
#########
class Model

Model::factory = (input) ->
  if input instanceof Array
    input = (Model::factory val for val in input)
  else if input instanceof Object and (input not instanceof Model)
    if typeof input.type? and typeof Reading.Models[input.type] is "function"
      input = new Reading.Models[input.type](input)
    else
      for prop, val of input
        input[prop] = Model::factory val
  input

########
# Page #
########
class Reading.Models.Page extends Backbone.Model
  comments: (success) ->
    API::call "pages/#{@id}/comments",
      success: success

class Reading.Collections.PagesCollection extends Backbone.Collection
  model: Reading.Models.Page
  url: '/pages'

########
# User #
########
class Reading.Models.User extends Backbone.Model

class Reading.Collections.UsersCollection extends Backbone.Collection
  model: Reading.Models.User
  url: '/users'

########
# Post #
########
class Reading.Models.Post extends Backbone.Model
  initialize: (p) ->
    @id = p.id
    @yn = p.yn if p.yn?
    @wrapped_url = p.wrapped_url
    @page = p.page if p.page?
    @updated_at = new Date
    @loading = false
  short_url: ->
    "#{SHORT_DOMAIN}/p/#{base58.encode(@id)}"
  save: (success) ->
    @loading = new Date
    API::call "posts/#{@id}/update",
      data: {post: {yn: @yn}}
      complete: (jqXHR, textStatus) =>
        @loading = false
      success: (data, textStatus, jqXHR) =>
        @updated_at = new Date
        success data.response if success
  touch: (success) ->
    @save success

Reading.Models.Post::find_or_create = (data, success) ->
  # validations
  return alert errors.general if !data.url or data.url is "about:blank"

  # don't send the null title or else it'll get posted
  delete data.title if data.title is null
  API::call "posts/create",
    data: data
    success: success
    error: (jqXHR, textStatus, errorThrown) ->
      switch errorThrown
        when "Bad Request"
          alert errors.general
        when "Forbidden"
          $("#r_am").remove() # need to encapsulate this into the menu itself
          alert errors.forbidden

Reading.Models.Post::current = {}

class Reading.Collections.PostsCollection extends Backbone.Collection
  model: Reading.Models.Post
  url: '/posts'

###########
# Comment #
###########
class Reading.Models.Comment extends Backbone.Model

Reading.Models.Comment::create = (data, success) ->
  # validations
  return alert errors.general if !data.body || !data.page_id
  API::call "comments/create",
    data: data,
    success: success

class Reading.Collections.CommentsCollection extends Backbone.Collection
  model: Reading.Models.Comment
  url: '/comments'

############
# Provider #
############
class Reading.Models.Provider extends Backbone.Model
  url: (post) ->
    vals =
      url: post.page.url
      short_url: "http://#{post.short_url()}"
      wrapped_url: post.wrapped_url
      title: post.page.title
    parsed_url = @get("url_scheme")
    for val of vals
      parsed_url = parsed_url.replace("{{#{val}}}", encodeURIComponent(vals[val]))
    parsed_url

class Reading.Collections.ProvidersCollection extends Backbone.Collection
  model: Reading.Models.Provider
  url: '/providers'

#-----------------------------------------
# Controllers

##############
# Controller #
##############
class Controller

#######################
# Comments_Controller #
#######################
class Comments_Controller

Comments_Controller::init = ->
  $reading.on "keyup", "textarea", (e) ->
    if e.which is 13
      Reading.Models.Comment::create
        body: $(this).val()
        page_id: Reading.Models.Post::current.page.id
      false

#-----------------------------------------
# Views

########
# User #
########
Reading.Views.Users ||= {}

class Reading.Views.Users.UserView extends Backbone.View
  template: Hogan.compile "<a href=\"http://#{DOMAIN}/{{username}}\"><img src=\"{{mini_avatar}}\"> {{display_name}}</a>"

  tagName: "li"
  className: "r_user"

  events:
    "click a:not(.r_tagalong)" : "show"

  show: ->
    render_popover @$("a").attr("href")
    false

  render: ->
    $(@el).html(@template.render(@model.toJSON()))
    return this

class Reading.Views.Users.UsersCollectionView extends Backbone.View
  tagName: "ul"

  initialize: ->
    @options.users.bind('reset', @addAll)

  addAll: =>
    @options.users.each(@addOne)

  addOne: (user) =>
    view = new Reading.Views.Users.UserView({model : user})
    @$el.append(view.render().el)

  render: =>
    @addAll()
    return this

#############
# Providers #
#############
Reading.Views.Providers ||= {}

class Reading.Views.Providers.ProviderView extends Backbone.View
  template: Hogan.compile "<a href=\"#\" class=\"r_share\">{{name}}</a>"

  events:
    "click" : "run"

  tagName: "li"

  run: ->
    @model.get("action")(@model.url Reading.Models.Post::current)
    false

  render: ->
    $(@el).html(@template.render(@model.toJSON()))
    return this

class Reading.Views.Providers.ProviderCollectionView extends Backbone.View
  tagName: "ul"

  initialize: ->
    @options.providers.bind('reset', @addAll)

  addAll: =>
    @options.providers.each(@addOne)

  addOne: (provider) =>
    view = new Reading.Views.Providers.ProviderView({model : provider})
    @$el.append(view.render().el)

  render: =>
    @addAll()
    return this

#-----------------------------------------
# Vars

providers = new Reading.Collections.ProvidersCollection [
  new Reading.Models.Provider
    name: "Twitter"
    url_scheme: "https://twitter.com/share?url={{short_url}}&text=✌%20Reading%20%22{{title}}%22"
    action: (url) ->
      popup url, 475, 345
  new Reading.Models.Provider
    name: "Facebook"
    url_scheme: "https://www.facebook.com/sharer.php?u={{wrapped_url}}&t={{title}}"
    action: (url) ->
      popup url, 520, 370
  new Reading.Models.Provider
    name: "Tumblr"
    url_scheme: "http://www.tumblr.com/share?v=3&u={{wrapped_url}}&t=✌%20Reading%20%22{{title}}%22"
    action: (url) ->
      popup url, 450, 430
  new Reading.Models.Provider
    name: "Instapaper"
    url_scheme: "http://www.instapaper.com/hello2?url={{url}}&title={{title}}"
    action: (url) ->
      window.location = url
  new Reading.Models.Provider
    name: "Readability"
    url_scheme: "http://www.readability.com/save?url={{url}}"
    action: (url) ->
      window.location = url
  new Reading.Models.Provider
    name: "Pocket"
    url_scheme: "https://getpocket.com/save?url={{url}}&title={{title}}"
    action: (url) ->
      popup url, 490, 400
  new Reading.Models.Provider
    name: "Pinboard"
    url_scheme: "https://pinboard.in/add?showtags=yes&url={{url}}&title={{title}}&tags=Reading.am"
    action: (url) ->
      popup url, 490, 400
  new Reading.Models.Provider
    name: "Email"
    url_scheme: "mailto:?subject=✌%20Reading%20%22{{title}}%22&body={{wrapped_url}}"
    action: (url) ->
      window.location.href = url
]

#-----------------------------------------
# Renderer for peace sign loader

$reading = {}
render_loading = ->
  $reading = $("#r_am")
  if(!$reading.length)
    $css  = $('<style type="text/css">').html('<%= IO.read("#{Rails.root}/app/assets/stylesheets/bookmarklet/loader.css").gsub(/\n|\t|\r/,"").gsub(/\s{2,}/," ") %>').appendTo("head")
    $reading = $('<%= IO.read("#{Rails.root}/app/views/bookmarklet/loader.html").gsub(/\n|\t|\r/,"").gsub(/\s{2,}/," ") %>').prependTo("body")
    $reading.fadeIn 500
  else
    $("#r_icon", $reading).animate "margin-top": "-18px"

#-----------------------------------------
# Renderer for popover

render_popover = (src) ->
  $popover = $("#r_popover")
  if $popover.length # check for existing popover
    $popover.find("iframe").attr
      src: src
  else
    $body =     $("body")
    $bg =       $("<div>")
    $iframe =   $("<iframe>").attr src: src
    $popover =  $("<div>").attr id: "r_popover"

    $popover
      .append($bg)
      .append($iframe)
      .on "click", ->
        $popover.remove()
        $body.removeClass "r_popped_over"

    $body.addClass("r_popped_over").append $popover
    $popover.fadeIn("fast")


#-----------------------------------------
# Renderer for yellow popover

render_menu = (post, readers = false) ->
  readers   = false if readers.length is 0

  $icon     = $("#r_icon", $reading)
  $actions  = $("#r_actions", $reading)
  $wrapper  = $("#r_wrp", $reading)
  $stuff    = $("#r_stuff_menu", $reading)
  $readers  = $("#r_readers", $reading)

  first_post= !$reading.hasClass('r_submitted')

  readers = new Reading.Collections.UsersCollection(readers)
  readers_view = new Reading.Views.Users.UsersCollectionView({id: "r_readers", users: readers})
  $wrapper.after(readers_view.render().el)
#  $readers.slideUp().html '<li id=\"r_other\">&#8258; Other Readers</li>' # clear previous readers
#  if readers
#    $.each readers, (i, user) ->
#      $li = $("<li class=\"r_user\">
#        <a href=\"http://#{DOMAIN}/#{user.get("username")}\">
#          <img src=\"#{user.get("mini_avatar")}\"> #{user.get("display_name")}
#        </a>
#      </li>")
#      if user.get("posts")?
#        for dir in [["before","&laquo;"],["after","&raquo;"]] when user.get("posts")[dir[0]]?
#          $li.append $("<a>").html(dir[1]).attr
#            class: "r_tagalong r_#{dir[0]}"
#            href:   user.get("posts")[dir[0]].wrapped_url
#            title:  user.get("posts")[dir[0]].title
#      $readers.append $li

  $wrapper.delay(500).animate
    height: "29px"
    width: $actions.width()

  $icon.delay(500).animate "margin-top": "-56px", ->
    $reading.addClass('r_submitted')
  readers_view.$el.delay(800).slideDown() if readers

  if first_post
    $('#r_close').click ->
      $reading.fadeOut 400, ->
        $reading.remove()
      false

    show_stuff = ->
      $("#r_stuff_menu", $reading).show()
      $readers.hide() if readers
      $('#r_stuff').addClass "r_active"
      false

    hide_stuff = ->
      $("#r_stuff_menu", $reading).hide()
      $readers.show() if readers
      $('#r_stuff').removeClass "r_active"
      false

    view = new Reading.Views.Providers.ProviderCollectionView({id: "r_stuff_menu", providers: providers})
    $wrapper.after(view.render().el)

    $('#r_stuff').on
      mouseenter: show_stuff
      click: -> false

    $reading.on "mouseleave", hide_stuff
    $actions.on "mouseenter", "a:not(#r_stuff)", hide_stuff

    $reading.on "click", "#r_yep, #r_nope", ->
      yep_nope post, $(this).is('#r_yep')

    $reading.on "click", ".r_share", ->
      provider = providers.get($(this).attr('data-provider_id'))
      provider.run post
      false

  # sync up the UI with the model that was returned on find_or_create
  $('#r_yep, #r_nope').removeClass("#{active} #{inactive}")
  yep_nope(post, post.yn) if post.yn?


#-----------------------------------------
# Post and render the yep nope state

yep_nope = (post, state) ->
  $this   = (if state then $('#r_yep') else $('#r_nope'))
  $other  = (if state then $('#r_nope') else $('#r_yep'))

  # set the UI
  if $this.hasClass(active)
    $this.removeClass active
    $other.removeClass inactive
    state = null
  else
    $this.removeClass(inactive).addClass active
    $other.removeClass(active).addClass inactive

  if post.yn isnt state
    # show the loader
    $close = $('#r_close')
    i = 0
    shapes = ['&#10043;', '&#10044;', '&#10045;', '&#10046;']
    loading = setInterval(->
      $close.html shapes[i]
      i = (if i < shapes.length - 1 then i + 1 else 0)
    , 250)
    # save the post state
    post.yn = state
    post.save ->
      clearInterval loading
      $close.html '&#10005;'
  #return
  false

#-----------------------------------------
# Script Loader

load_script = (url, success) ->
  script = document.createElement('script')
  script.src = url
  head = document.getElementsByTagName('head')[0]
  done = false
  script.onload = script.onreadystatechange = =>
    if not done and (not @readyState or @readyState is 'loaded' or @readyState is 'complete')
      done = true
      success()
      script.onload = script.onreadystatechange = null
      head.removeChild script
  head.appendChild script

#-----------------------------------------
# Submit the post

self = this
reading.submit = submit = (params) ->
  render_loading() if platform isnt "redirect"
  Reading.Models.Post::find_or_create params, (data) ->
    if platform is "redirect"
      # forward back through to Reading so that the user's
      # token doesn't show up in the referrer
      window.location = if window.location.href.indexOf('/t/') > -1 then "http://#{DOMAIN}/t/-/#{params.url}" else params.url
    else
      post = data.post
      readers = data.readers
      # update the date_created every 15 seconds ala chartbeat
      # consider not doing this for context-menu posts
      clearInterval self.interval if self.interval?
      self.interval = setInterval (->
        post.touch() if win_focus and not post.loading and new Date - post.updated_at >= 15000
      ), 2500

      Reading.Models.Post::current = post
      render_menu post, readers

#-----------------------------------------
# Check the bookmarklet version

up_to_date = ->
  if !latest_versions[platform]?
    true
  else
    String(version).replace(/\./g,'') >= String(latest_versions[platform]).replace(/\./g,'')


#-----------------------------------------
# Prompt to upgrade

upgrade = ->
  $.getScript "//#{DOMAIN}/assets/bookmarklet/upgrade.js"

#-----------------------------------------
# Initialize!

init = ->
  Backbone.setDomLibrary $
  # fire an event to let people know reading is ready
  # can't seem to use jquery.trigger for events attached
  # without jquery
  e = document.createEvent 'Event'
  e.initEvent 'reading.ready', true, true
  document.dispatchEvent e
  reading.ready = true

  $(window).focus(->
    win_focus = true
  ).blur(->
    win_focus = false
  )

  if platform is "redirect" or platform is "bookmarklet"
    if platform is "redirect"
      url   = parse_url()
      title = null
      return window.location = url if token is "-" or !token
    else
      url   = window.location.href
      title = window.document.title

    submit {url: url, title: title, referrer_id: reading.referrer_id ? 0}
    Comments_Controller::init()

#-----------------------------------------
# Check for jQuery and initialize

if jQuery? and jQuery().jquery? and jQuery().jquery >= "1.7"
  $ = jQuery
  if up_to_date() then init() else upgrade()
else
  load_script "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js", ->
    if jQuery?
      $ = jQuery.noConflict()
      if up_to_date() then init() else upgrade()
    else
      alert errors.loading
