#-----------------------------------------
# App Structure

Reading =
  Models: {}
  Collections: {}
  Routers: {}
  Views: {}

<% if Rails.env == 'development' %>
window.r_ = Reading
<% end %>

#-----------------------------------------
# Libs

libs = {}

<%= IO.read "#{Rails.root}/app/assets/javascripts/libs/base58.coffee" %>
base58 = libs.encdec()

<% ['underscore','hogan','backbone'].each do |lib| %>
`<%= IO.read "#{Rails.root}/app/assets/javascripts/libs/#{lib}.js" %>`
<% end %>

# Backbone addons
<% ['nest_collection'].each do |lib| %>
<%= IO.read "#{Rails.root}/app/assets/javascripts/backbone/addons/#{lib}.coffee" %>
<% end %>

# jQuery plugins
load_$plugins = ->
<% ['humane'].each do |lib| %>
  `<%= IO.read "#{Rails.root}/app/assets/javascripts/jquery/#{lib}.js" %>`
<% end %>
  return # need this return here else it returns too soon

#-----------------------------------------
# Debug

log = <% if Rails.env == 'development' %> -> console.log.apply console, arguments <% else %> -> <% end %>

#-----------------------------------------
# Config Vars

DOMAIN = "<%= DOMAIN %>"
SHORT_DOMAIN = "<%= SHORT_DOMAIN %>"
PROTOCOL = "http"
API_URL = "#{PROTOCOL}://#{DOMAIN}/api"
win_focus = true
reading.ready = false
on_reading = window.location.host.indexOf("reading.am") is 0 or
             window.location.host.indexOf("staging.reading.am") is 0 or
             window.location.host.indexOf("0.0.0.0") is 0
token = reading.token ? null
platform = reading.platform ? (if on_reading then "redirect" else "bookmarklet")
version = reading.version ? "0.0.0"

latest_versions =
  bookmarklet: "<%= BOOKMARKLET_VERSION %>"

#-----------------------------------------
# Content Vars

active = "r_active"
inactive = "r_inactive"
errors =
  general: "Sorry, something went wrong. If you keep getting this error, would you mind letting us know at hello@reading.am?"
  forbidden: "** You must be signed in to post to Reading **\nSign in or create an account at http://#{DOMAIN}"
  loading: "Sorry, we were unable to load Reading. If you keep getting this error, would you mind letting us know at hello@reading.am?"

#-----------------------------------------
# Helpers

parse_url = ->
  url = window.location.href.split(window.location.host)[1].substring(1)
  while url.substring(0, 2) is 't/' or url.substring(0, 2) is 'p/'
    url = url.substring(url.indexOf('/', 2) + 1)
  url = "http://#{url}" if url.indexOf('://') is -1
  url

popup = (url, width, height) ->
  window.open url, "r_win", "location=0,toolbars=0,status=0,directories=0,menubar=0,resizable=0,width=#{width},height=#{height}"

#-----------------------------------------
# Sync for JSONP

methodMap =
  create: 'POST',
  update: 'PUT',
  delete: 'DELETE',
  read:   'GET'

Backbone._sync = Backbone.sync
Backbone.sync = (method, model, options) ->
  console.log method, model, options

  type = methodMap[method]
  options.dataType = "jsonp"
  options.data = {_method: type}
  options.data.token = token if token

  if model && (method == 'create' || method == 'update')
    options.data.model = model.toJSON()

  if !options.url
    options.url = _.result(model, 'url') || urlError()

  return $.ajax options

#-----------------------------------------
# Models

#######
# API #
#######
class API

API::call = (method, params) ->
    data = if params.data? then params.data else {}
    data.token = token if token

    complete = if params.complete? then params.complete else ->
    success = if params.success? then params.success else log
    error = if params.error? then params.error else (jqXHR, textStatus, errorThrown) ->
      log jqXHR, textStatus, errorThrown
      switch errorThrown
        when "Bad Request"
          alert errors.general
        when "Forbidden"
          alert errors.forbidden

    $.ajax
      url: "//#{DOMAIN}/#{method}.json"
      dataType: "jsonp"
      data: data
      complete: complete
      error: error
      success: (data, textStatus, jqXHR) ->
        if data.meta.status < 400
          success Backbone.Model::factory(data.response)
        else
          jqXHR.status = data.meta.status
          jqXHR.responseText = data
          error jqXHR, textStatus, data.meta.msg

#########
# Model #
#########
# Override the url method to append the absolute API route
Backbone.Model::_url = Backbone.Model::url
Backbone.Model::url = -> "#{API_URL}/#{@_url()}"

Backbone.Model::factory = (input) ->
  if input instanceof Array
    input = (Backbone.Model::factory val for val in input)
    if input[0] instanceof Object and input[0].type? and Reading.Collections["#{input[0].type}s"] is "function"
      input = new Reading.Collections["#{input[0].type}s"](input)
  else if input instanceof Object and (input not instanceof Backbone.Model)
    for prop, val of input
      input[prop] = Backbone.Model::factory val
    if input.type? and typeof Reading.Models[input.type] is "function"
      input = new Reading.Models[input.type](input)
  input

Backbone.Model::urlRoot = ->
  "#{@type.toLowerCase()}s"

Backbone.Model::parse = Backbone.Collection::parse = (response) ->
  Backbone.Model::factory response.response[@type.toLowerCase()]

########
# Page #
########
class Reading.Models.Page extends Backbone.Model
  type: "Page"

  initialize: ->
    self = this

    @users = @nestCollection('users', new Reading.Collections.Users(@get('users')))
    @users.url = => "#{self.url()}/users"

    @comments = @nestCollection('comments', new Reading.Collections.Comments(@get('comments')))
    @comments.url = => "#{self.url()}/comments"


  comments: (success) ->
    API::call "pages/#{@id}/comments",
      success: success

class Reading.Collections.Pages extends Backbone.Collection
  type: "Pages"
  model: Reading.Models.Page

########
# User #
########
class Reading.Models.User extends Backbone.Model
  type: "User"

class Reading.Collections.Users extends Backbone.Collection
  type: "Users"
  model: Reading.Models.User

########
# Post #
########
class Reading.Models.Post extends Backbone.Model
  type: "Post"

#  initialize: (p) ->
#    @id = p.id
#    @yn = p.yn if p.yn?
#    @wrapped_url = p.wrapped_url
#    @page = p.page if p.page?
#    @updated_at = new Date
#    @loading = false
  short_url: ->
    "#{SHORT_DOMAIN}/p/#{base58.encode(@id)}"

  touch: @save

Reading.Models.Post::find_or_create = (data, success) ->
  # validations
  return alert errors.general if !data.url or data.url is "about:blank"

  # don't send the null title or else it'll get posted
  delete data.title if data.title is null
  API::call "posts/create",
    data: data
    success: success
    error: (jqXHR, textStatus, errorThrown) ->
      switch errorThrown
        when "Bad Request"
          alert errors.general
        when "Forbidden"
          $("#r_am").remove() # need to encapsulate this into the menu itself
          alert errors.forbidden

Reading.Models.Post::current = {}

class Reading.Collections.Posts extends Backbone.Collection
  type: "Posts"
  model: Reading.Models.Post

###########
# Comment #
###########
class Reading.Models.Comment extends Backbone.Model
  type: "Comment"
  validate: (attr) ->
    if !attr.body || !attr.page_id
      return errors.general

class Reading.Collections.Comments extends Backbone.Collection
  type: "Comments"
  model: Reading.Models.Comment

############
# Provider #
############
class Reading.Models.Provider extends Backbone.Model
  type: "Provider"
  url: (post) ->
    vals =
      url: post.page.url
      short_url: "http://#{post.short_url()}"
      wrapped_url: post.wrapped_url
      title: post.page.title
    parsed_url = @get("url_scheme")
    for val of vals
      parsed_url = parsed_url.replace("{{#{val}}}", encodeURIComponent(vals[val]))
    parsed_url

class Reading.Collections.Providers extends Backbone.Collection
  type: "Providers"
  model: Reading.Models.Provider


#-----------------------------------------
# Views

########
# User #
########
Reading.Views.Users ||= {}

class Reading.Views.Users.UserView extends Backbone.View
  template: Hogan.compile "
    <a href=\"http://#{DOMAIN}/{{username}}\">
      <img src=\"{{mini_avatar}}\"> {{display_name}}
    </a>
    {{#posts}}
      {{#posts.before}}<a href=\"{{posts.before.wrapped_url}}\" class=\"r_tagalong r_before\" title=\"{{posts.before.title}}\">&laquo;</a>{{/posts.before}}{{#posts.after}}<a href=\"{{posts.after.wrapped_url}}\" class=\"r_tagalong r_after\" title=\"{{posts.after.title}}\">&raquo;</a>{{/posts.after}}
    {{/posts}}"

  tagName: "li"
  className: "r_user"

  events:
    "click a:not(.r_tagalong)" : "show"

  show: ->
    render_popover @$("a").attr("href")
    false

  render: =>
    $(@el).html(@template.render(@model.toJSON()))
    return this

class Reading.Views.Users.UsersView extends Backbone.View
  tagName: "ul"

  initialize: ->
    @options.users.bind('reset', @addAll)

  addAll: =>
    @options.users.each(@addOne)

  addOne: (user) =>
    view = new Reading.Views.Users.UserView({model : user})
    @$el.append(view.render().el)

  render: =>
    @addAll()
    return this

###########
# Comment #
###########
Reading.Views.Comments ||= {}

class Reading.Views.Comments.CommentView extends Backbone.View
  template: Hogan.compile "
    <div class=\"r_comment_header\">
      <div class=\"r_user\"></div>
      <time datetime=\"{{updated_at}}\"></time>
      <div class=\"r_comment_actions\">
        <a href=\"#\" class=\"r_reply\">reply</a>
        <a href=\"#\" class=\"r_destroy\">delete</a>
      </div>
    </div>
    <div class=\"r_comment_body\">{{body}}</div>
  "

  tagName: "li"
  className: "r_comment"

  events:
    "click .r_reply" : "reply"
    "click .r_destroy" : "destroy"

  initialize: ->
    @model.bind 'change', @render, this
    @model.bind 'destroy', @remove, this

  reply: ->
    alert "reply will go here"
    return false

  destroy: ->
    if confirm "Are you sure you want to delete this comment?"
      @model.destroy()

    return false

  render: =>
    $(@el).html(@template.render(@model.toJSON()))
    @$("time").humaneDates()
    child_view = new Reading.Views.Users.UserView
      model: @model.get('user')
      el:   @$(".r_user")
    child_view.render()
    return this

class Reading.Views.Comments.CommentsView extends Backbone.View
  tagName: "ul"

  events:
    "keypress textarea" : "createOnEnter"

  initialize: ->
    @options.comments.bind 'reset', @addAll
    @options.comments.bind 'add', @addOne

  addAll: =>
    @options.comments.each(@addOne)

  addOne: (comment) =>
    view = new Reading.Views.Comments.CommentView({model : comment})
    @$el.append(view.render().el)

  createOnEnter: (e) ->
    if e.keyCode is 13
      @options.comments.create
        body: @$("textarea").val(),
        user: Reading.Models.Post::current.get("user")
        page_id: Reading.Models.Post::current.get("page").get("id")
      @$("textarea").val ''

  render: =>
    @addAll()
    return this

#############
# Providers #
#############
Reading.Views.Providers ||= {}

class Reading.Views.Providers.ProviderView extends Backbone.View
  template: Hogan.compile "<a href=\"#\" class=\"r_share\">{{name}}</a>"

  events:
    "click" : "run"

  tagName: "li"

  run: ->
    @model.get("action")(@model.url Reading.Models.Post::current)
    false

  render: ->
    $(@el).html(@template.render(@model.toJSON()))
    return this

class Reading.Views.Providers.ProvidersView extends Backbone.View
  tagName: "ul"

  initialize: ->
    @options.providers.bind('reset', @addAll)

  addAll: =>
    @options.providers.each(@addOne)

  addOne: (provider) =>
    view = new Reading.Views.Providers.ProviderView({model : provider})
    @$el.append(view.render().el)

  render: =>
    @addAll()
    return this

#-----------------------------------------
# Vars

providers = new Reading.Collections.Providers [
  new Reading.Models.Provider
    name: "Twitter"
    url_scheme: "https://twitter.com/share?url={{short_url}}&text=✌%20Reading%20%22{{title}}%22"
    action: (url) ->
      popup url, 475, 345
  new Reading.Models.Provider
    name: "Facebook"
    url_scheme: "https://www.facebook.com/sharer.php?u={{wrapped_url}}&t={{title}}"
    action: (url) ->
      popup url, 520, 370
  new Reading.Models.Provider
    name: "Tumblr"
    url_scheme: "http://www.tumblr.com/share?v=3&u={{wrapped_url}}&t=✌%20Reading%20%22{{title}}%22"
    action: (url) ->
      popup url, 450, 430
  new Reading.Models.Provider
    name: "Instapaper"
    url_scheme: "http://www.instapaper.com/hello2?url={{url}}&title={{title}}"
    action: (url) ->
      window.location = url
  new Reading.Models.Provider
    name: "Readability"
    url_scheme: "http://www.readability.com/save?url={{url}}"
    action: (url) ->
      window.location = url
  new Reading.Models.Provider
    name: "Pocket"
    url_scheme: "https://getpocket.com/save?url={{url}}&title={{title}}"
    action: (url) ->
      popup url, 490, 400
  new Reading.Models.Provider
    name: "Pinboard"
    url_scheme: "https://pinboard.in/add?showtags=yes&url={{url}}&title={{title}}&tags=Reading.am"
    action: (url) ->
      popup url, 490, 400
  new Reading.Models.Provider
    name: "Email"
    url_scheme: "mailto:?subject=✌%20Reading%20%22{{title}}%22&body={{wrapped_url}}"
    action: (url) ->
      window.location.href = url
]

#-----------------------------------------
# Renderer for peace sign loader

$reading = {}
render_loading = ->
  $reading = $("#r_am")
  if(!$reading.length)
    $css  = $('<style type="text/css">').html('<%= IO.read("#{Rails.root}/app/assets/stylesheets/bookmarklet/loader.css").gsub(/\n|\t|\r/,"").gsub(/\s{2,}/," ") %>').appendTo("head")
    $reading = $('<%= IO.read("#{Rails.root}/app/views/bookmarklet/loader.html").gsub(/\n|\t|\r/,"").gsub(/\s{2,}/," ") %>').prependTo("body")
    $reading.fadeIn 500
  else
    $("#r_icon", $reading).animate "margin-top": "-18px"

#-----------------------------------------
# Renderer for popover

render_popover = (src) ->
  $popover = $("#r_popover")
  if $popover.length # check for existing popover
    $popover.find("iframe").attr
      src: src
  else
    $body =     $("body")
    $bg =       $("<div>")
    $iframe =   $("<iframe>").attr src: src
    $popover =  $("<div>").attr id: "r_popover"

    $popover
      .append($bg)
      .append($iframe)
      .on "click", ->
        $popover.remove()
        $body.removeClass "r_popped_over"

    $body.addClass("r_popped_over").append $popover
    $popover.fadeIn("fast")


#-----------------------------------------
# Renderer for yellow popover

render_menu = (post, readers = false) ->
  readers   = false if readers.length is 0

  $icon     = $("#r_icon", $reading)
  $actions  = $("#r_actions", $reading)
  $wrapper  = $("#r_wrp", $reading)

  first_post= !$reading.hasClass('r_submitted')

#  $readers.slideUp().html '' # clear previous readers

  # readers
  if readers
    readers = new Reading.Collections.Users readers
    readers_view = new Reading.Views.Users.UsersView({id: "r_readers", users: readers})
    $wrapper.after(readers_view.render().$el.prepend("<li id=\"r_other\">&#8258; Other Readers</li>"))

  # comments
  Reading.Models.Post::current.get("page").comments.fetch
    success: (collection, response) ->
      comments_view = new Reading.Views.Comments.CommentsView({id: "r_comments", comments: collection})
      $reading.append(comments_view.render().$el.prepend("<li><textarea placeholder=\"Add a comment\"></textarea></li>"))


  $wrapper.delay(500).animate
    height: "29px"
    width: $actions.width()

  $icon.delay(500).animate "margin-top": "-56px", ->
    $reading.addClass('r_submitted')
  readers_view.$el.delay(800).slideDown() if readers

  if first_post
    $('#r_close').click ->
      $reading.fadeOut 400, ->
        $reading.remove()
      false

    show_stuff = ->
      share_view.$el.show()
      readers_view.$el.hide() if readers
      $('#r_stuff').addClass "r_active"
      false

    hide_stuff = ->
      share_view.$el.hide()
      readers_view.$el.show() if readers
      $('#r_stuff').removeClass "r_active"
      false

    share_view = new Reading.Views.Providers.ProvidersView({id: "r_stuff_menu", providers: providers})
    $wrapper.after(share_view.render().el)

    $('#r_stuff').on
      mouseenter: show_stuff
      click: -> false

    $reading.on "mouseleave", hide_stuff
    $actions.on "mouseenter", "a:not(#r_stuff)", hide_stuff

    $reading.on "click", "#r_yep, #r_nope", ->
      yep_nope post, $(this).is('#r_yep')

    $reading.on "click", ".r_share", ->
      provider = providers.get($(this).attr('data-provider_id'))
      provider.run post
      false

  # sync up the UI with the model that was returned on find_or_create
  $('#r_yep, #r_nope').removeClass("#{active} #{inactive}")
  yep_nope(post, post.yn) if post.yn?


#-----------------------------------------
# Post and render the yep nope state

yep_nope = (post, state) ->
  $this   = (if state then $('#r_yep') else $('#r_nope'))
  $other  = (if state then $('#r_nope') else $('#r_yep'))

  # set the UI
  if $this.hasClass(active)
    $this.removeClass active
    $other.removeClass inactive
    state = null
  else
    $this.removeClass(inactive).addClass active
    $other.removeClass(active).addClass inactive

  if post.yn isnt state
    # show the loader
    $close = $('#r_close')
    i = 0
    shapes = ['&#10043;', '&#10044;', '&#10045;', '&#10046;']
    loading = setInterval(->
      $close.html shapes[i]
      i = (if i < shapes.length - 1 then i + 1 else 0)
    , 250)
    # save the post state
    post.yn = state
    post.save ->
      clearInterval loading
      $close.html '&#10005;'
  #return
  false

#-----------------------------------------
# Script Loader

load_script = (url, success) ->
  script = document.createElement('script')
  script.src = url
  head = document.getElementsByTagName('head')[0]
  done = false
  script.onload = script.onreadystatechange = =>
    if not done and (not @readyState or @readyState is 'loaded' or @readyState is 'complete')
      done = true
      success()
      script.onload = script.onreadystatechange = null
      head.removeChild script
  head.appendChild script

#-----------------------------------------
# Submit the post

self = this
reading.submit = submit = (params) ->
  render_loading() if platform isnt "redirect"
  Reading.Models.Post::find_or_create params, (data) ->
    if platform is "redirect"
      # forward back through to Reading so that the user's
      # token doesn't show up in the referrer
      window.location = if window.location.href.indexOf('/t/') > -1 then "http://#{DOMAIN}/t/-/#{params.url}" else params.url
    else
      post = data.post
      readers = data.readers
      # update the date_created every 15 seconds ala chartbeat
      # consider not doing this for context-menu posts
      clearInterval self.interval if self.interval?
      self.interval = setInterval (->
        post.touch() if win_focus and not post.loading and new Date - post.updated_at >= 15000
      ), 2500

      Reading.Models.Post::current = post
      render_menu post, readers

#-----------------------------------------
# Check the bookmarklet version

up_to_date = ->
  if !latest_versions[platform]?
    true
  else
    String(version).replace(/\./g,'') >= String(latest_versions[platform]).replace(/\./g,'')


#-----------------------------------------
# Prompt to upgrade

upgrade = ->
  $.getScript "//#{DOMAIN}/assets/bookmarklet/upgrade.js"

#-----------------------------------------
# Initialize!

init = ->
  # we need this because we load jQuery after Backbone
  Backbone.setDomLibrary $
  load_$plugins()

  # fire an event to let people know reading is ready
  # can't seem to use jquery.trigger for events attached
  # without jquery
  e = document.createEvent 'Event'
  e.initEvent 'reading.ready', true, true
  document.dispatchEvent e
  reading.ready = true

  $(window).focus(->
    win_focus = true
  ).blur(->
    win_focus = false
  )

  setInterval ->
    $("time").humaneDates()
  , 5000

  if platform is "redirect" or platform is "bookmarklet"
    if platform is "redirect"
      url   = parse_url()
      title = null
      return window.location = url if token is "-" or !token
    else
      url   = window.location.href
      title = window.document.title

    submit {url: url, title: title, referrer_id: reading.referrer_id ? 0}

#-----------------------------------------
# Check for jQuery and initialize

if jQuery? and jQuery().jquery? and jQuery().jquery >= "1.7"
  $ = jQuery
  if up_to_date() then init() else upgrade()
else
  load_script "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js", ->
    if jQuery?
      $ = jQuery.noConflict()
      if up_to_date() then init() else upgrade()
    else
      alert errors.loading
